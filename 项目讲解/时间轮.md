## 时间轮的作用

时间轮的作用是为了定时踢掉超时的TCP连接，所谓超时的TCP连接指的双方长时间没有通信的连接。由于这些超时连接没有通信，依然占用服务器资源，所以需要清理掉。服务器和客户端长时间不通信的两种情况如下：一种是连接正常，只是单纯不需要通信。另一种是客户端出现意外。
由于muduo不会主动关闭连接，都是等待客户端关闭后再关闭服务端（即使主动关闭也是先关闭自己的写端，等客户端关闭后，在关闭自己的读端，之所以这样做是为了服务器不会漏收对方消息，这里不展开说明），如果客户端意外断电关机，那么服务端就无法受到FIN，进而无法关闭连接，此时，如果应用层没有实现心跳机制、也没有为该连接的fd设置 `SO_KEEPALIVE`，该连接就会一直占用服务器资源。
为了避免上述无效连接浪费服务器资源，要么设置 `SO_KEEPALIVE`，要么应用层实现心跳机制。如果是 **实现心跳机制，就需要定时器实现的时间轮，用于以便定时清理无效连接** 。

## 定时器实现思路

见定时器章。

### 时间轮长什么样？

时间轮使用的数据结构是个循环队列，本项目中是vector来实现的。代码如下：

```
template <typename T>
class CircularBuffer 
{
public:
    CircularBuffer(size_t size) : buffer(size), maxSize(size), head(0), tail(0), full(false) {}
    void enqueue(T item)；
    //查看队尾元素，不删除
    T& back()；
    bool isFull() const；
    bool isEmpty() const；
private:
    std::vector<T> buffer; //底层用的就vector
    size_t maxSize;
    size_t head; //头指针
    size_t tail; // 尾指针
    bool full;
};
```

如下图左边所示，它有个尾指针tail始终指向循环队列的尾部，它的每个槽都存储的一个std::unordered_set容器，这里把这个std::unordered_set叫Bucket（译为“桶”）

[![时间轮 (5).drawio (1).svg](https://camo.githubusercontent.com/40cc27343b35742848133d3010458503d8807ac93ef1a62eea3d445370a7cfce/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032332f7376672f32373232323730342f313638343333363134353031382d36353036313965622d643463622d343261322d383235382d3330393537373166303130322e73766723636c69656e7449643d7539373536383830622d313463642d342666726f6d3d64726f70266865696768743d3332342669643d753033306239646138266f726967696e4865696768743d323932266f726967696e57696474683d353432266f726967696e616c547970653d62696e61727926726174696f3d312e323526726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d3332383637267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7530626237346530622d626436312d343764362d393836612d3164306538303235386434267469746c653d2677696474683d363031)](https://camo.githubusercontent.com/40cc27343b35742848133d3010458503d8807ac93ef1a62eea3d445370a7cfce/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032332f7376672f32373232323730342f313638343333363134353031382d36353036313965622d643463622d343261322d383235382d3330393537373166303130322e73766723636c69656e7449643d7539373536383830622d313463642d342666726f6d3d64726f70266865696768743d3332342669643d753033306239646138266f726967696e4865696768743d323932266f726967696e57696474683d353432266f726967696e616c547970653d62696e61727926726174696f3d312e323526726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d3332383637267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7530626237346530622d626436312d343764362d393836612d3164306538303235386434267469746c653d2677696474683d363031)
Bucket中存储的是std::shared_ptr（至于为什么存储共享指针，后面会说）。Entry是个结构体，如下源码所示。Entry有个WeakTcpConnectionPtr类型的成员，为了简化理解，我们就认为Entry存储的就是TcpConnection的共享指针，即TcpConnectionPtr。**现在需要关注的是，Entry结构体在析构的时候会调用TcpConnection的shutdown函数来关闭连接。所以可以认为只要Entry析构了，连接就关闭了。这对接下来理解连接是怎么被踢掉的很重要。**

```c++
struct myEntry
{
    explicit myEntry(const WeakTcpConnectionPtr& weakConn) : weakConn_(weakConn) {}
    ~myEntry()
    {
        TcpConnectionPtr conn = weakConn_.lock();
        if (conn) conn->shutdown();
    }

	WeakTcpConnectionPtr weakConn_;
};

using Bucket = std::unordered_set<EntryPtr>;
using WeakConnectionList = CircularBuffer<Bucket>;  // 时间轮

```

### 连接是怎么被添加进时间轮的？

假设每个TCP连接最多存活时间为8s，时间轮每一秒转动一下（借助EventLoop::runEvery函数实现重复定时），所以我们需要一个有8个桶时间轮，第1个桶放1秒之后将要超时的连接，第2个桶放2秒之后将要超时的连接。 **刚建立连接时或者某个连接一收到数据就把自己放到时间轮队尾的桶中，即第8个桶** 

```c++
// 有新连接到来时，需要把连接添加到队尾的桶中
    void onConnection(const TcpConnectionPtr& conn)
    {
        if (conn->connected())
        {
            // 创建一个Entry，用来记录连接，即conn，Entry的析构函数会关闭连接
            EntryPtr entry(new myEntry(conn));
            // 在时间轮的队尾的桶中插入Entry，可简单理解为插入连接
            connectionBuckets_.back().insert(entry);
            WeakEntryPtr weakEntry(entry);
            conn->setContext(weakEntry);
        }
    }
    // 有新消息来的时候，把连接添加到队尾的桶中
    void onMessage(const TcpConnectionPtr& conn, Buffer* buf, Timestamp time)
    {
        std::string msg = buf->retrieveAllAsString();
        std::cout << msg << std::endl;
        conn->send(msg);
        WeakEntryPtr weakEntry(conn->getContext());
        EntryPtr entry(weakEntry.lock());
        if (entry)
        {
            // 在时间轮的队尾的桶中插入Entry，可简单理解为插入连接
            connectionBuckets_.back().insert(entry);
        }
    }
  
```

### 时间轮怎么踢掉连接？

现在假设图右边两个连接在未来8秒不会收到新数据，1秒后（时间轮转动1次后）、7秒后和8秒后，时间轮分别如下图所示。
[![时间轮1.drawio (1).svg](https://camo.githubusercontent.com/082d65ace7375b0b4d0c7fd1a6b110eaa8f8663db8b21011ecfb2e9020f4ee25/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032332f7376672f32373232323730342f313638343333323530343736342d31376130323634352d323263312d343261652d623963322d3531363564373832396231612e73766723636c69656e7449643d7561383263373662372d613139312d342666726f6d3d64726f702669643d753730633430643063266f726967696e4865696768743d323832266f726967696e57696474683d383933266f726967696e616c547970653d62696e61727926726174696f3d312e323526726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d3439333539267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7539646134663561382d666439652d343337652d383139642d3363633632313262626330267469746c653d)](https://camo.githubusercontent.com/082d65ace7375b0b4d0c7fd1a6b110eaa8f8663db8b21011ecfb2e9020f4ee25/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032332f7376672f32373232323730342f313638343333323530343736342d31376130323634352d323263312d343261652d623963322d3531363564373832396231612e73766723636c69656e7449643d7561383263373662372d613139312d342666726f6d3d64726f702669643d753730633430643063266f726967696e4865696768743d323832266f726967696e57696474683d383933266f726967696e616c547970653d62696e61727926726174696f3d312e323526726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d3439333539267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7539646134663561382d666439652d343337652d383139642d3363633632313262626330267469746c653d)
**时间轮的转动是通过向队尾插入一个新桶实现的，循环队列有这样一个好处，满了之后（时间轮刚初始化的时候就是满的，只不过每个槽都是空桶），每向其队尾添加一个元素，队首元素自动弹出。**

```c++
// 超时回调函数
void EchoServer::onTimer()
{
    // 在时间轮队尾添加一个新的空桶，这样队首的桶自然被弹出，桶中的Entry引用计数为0
	// 就会被析构，Entry析构又会关闭连接
    connectionBuckets_.push_back(Bucket());
}
  
```

* 1秒后：向队尾添加新的一个空桶，队首被弹出，所以有连接的那个桶所在位置为7，就好像时间轮转动了一下一样。
* 7秒后：有连接的那个桶处于队首位置，因为每过1秒，队尾都会添加一个新桶，队首的桶不断被弹出，所以7秒后自己就处于队首位置了。
* 8秒后：有连接的那个桶自己被弹出，被弹出后会，桶会被析构（自然，桶中的每个元素，即 `std::shared_ptr<Entry>`，都会被析构），此时 `std::shared_ptr<Entry>`引用计数为0，会调用Entry的析构函数，而Entry的析构函数又会调用shutdown关闭连接，连接关闭后TcpConnectionPtr引用计数减为0，也就完成了TcpConnection的析构，**这就是为什么桶中要存共享指针的原因：循环队列弹出队首的桶后，桶中的Entry就会因为引用计数减为0，自动关闭连接。**
